// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'wallet_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$WalletState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(double balance, String currency,
            List<dynamic> transactions, bool isBankLinked)
        loaded,
    required TResult Function(String message) error,
    required TResult Function() withdrawalSuccess,
    required TResult Function() withdrawalSuccess,
    required TResult Function() bankLinkSuccess,
    required TResult Function(String orderId, double amount, String keyId)
        paymentRequired,
    required TResult Function() topUpSuccess,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(double balance, String currency,
            List<dynamic> transactions, bool isBankLinked)?
        loaded,
    TResult? Function(String message)? error,
    TResult? Function()? withdrawalSuccess,
    TResult? Function()? withdrawalSuccess,
    TResult? Function()? bankLinkSuccess,
    TResult? Function(String orderId, double amount, String keyId)?
        paymentRequired,
    TResult? Function()? topUpSuccess,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(double balance, String currency,
            List<dynamic> transactions, bool isBankLinked)?
        loaded,
    TResult Function(String message)? error,
    TResult Function()? withdrawalSuccess,
    TResult Function()? withdrawalSuccess,
    TResult Function()? bankLinkSuccess,
    TResult Function(String orderId, double amount, String keyId)?
        paymentRequired,
    TResult Function()? topUpSuccess,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
    required TResult Function(_WithdrawalSuccess value) withdrawalSuccess,
    required TResult Function(_WithdrawalSuccess value) withdrawalSuccess,
    required TResult Function(_BankLinkSuccess value) bankLinkSuccess,
    required TResult Function(_PaymentRequired value) paymentRequired,
    required TResult Function(_TopUpSuccess value) topUpSuccess,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
    TResult? Function(_WithdrawalSuccess value)? withdrawalSuccess,
    TResult? Function(_WithdrawalSuccess value)? withdrawalSuccess,
    TResult? Function(_BankLinkSuccess value)? bankLinkSuccess,
    TResult? Function(_PaymentRequired value)? paymentRequired,
    TResult? Function(_TopUpSuccess value)? topUpSuccess,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    TResult Function(_WithdrawalSuccess value)? withdrawalSuccess,
    TResult Function(_WithdrawalSuccess value)? withdrawalSuccess,
    TResult Function(_BankLinkSuccess value)? bankLinkSuccess,
    TResult Function(_PaymentRequired value)? paymentRequired,
    TResult Function(_TopUpSuccess value)? topUpSuccess,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $WalletStateCopyWith<$Res> {
  factory $WalletStateCopyWith(
          WalletState value, $Res Function(WalletState) then) =
      _$WalletStateCopyWithImpl<$Res, WalletState>;
}

/// @nodoc
class _$WalletStateCopyWithImpl<$Res, $Val extends WalletState>
    implements $WalletStateCopyWith<$Res> {
  _$WalletStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$InitialImplCopyWith<$Res> {
  factory _$$InitialImplCopyWith(
          _$InitialImpl value, $Res Function(_$InitialImpl) then) =
      __$$InitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitialImplCopyWithImpl<$Res>
    extends _$WalletStateCopyWithImpl<$Res, _$InitialImpl>
    implements _$$InitialImplCopyWith<$Res> {
  __$$InitialImplCopyWithImpl(
      _$InitialImpl _value, $Res Function(_$InitialImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$InitialImpl implements _Initial {
  const _$InitialImpl();

  @override
  String toString() {
    return 'WalletState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(double balance, String currency,
            List<dynamic> transactions, bool isBankLinked)
        loaded,
    required TResult Function(String message) error,
    required TResult Function() withdrawalSuccess,
    required TResult Function() withdrawalSuccess,
    required TResult Function() bankLinkSuccess,
    required TResult Function(String orderId, double amount, String keyId)
        paymentRequired,
    required TResult Function() topUpSuccess,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(double balance, String currency,
            List<dynamic> transactions, bool isBankLinked)?
        loaded,
    TResult? Function(String message)? error,
    TResult? Function()? withdrawalSuccess,
    TResult? Function()? withdrawalSuccess,
    TResult? Function()? bankLinkSuccess,
    TResult? Function(String orderId, double amount, String keyId)?
        paymentRequired,
    TResult? Function()? topUpSuccess,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(double balance, String currency,
            List<dynamic> transactions, bool isBankLinked)?
        loaded,
    TResult Function(String message)? error,
    TResult Function()? withdrawalSuccess,
    TResult Function()? withdrawalSuccess,
    TResult Function()? bankLinkSuccess,
    TResult Function(String orderId, double amount, String keyId)?
        paymentRequired,
    TResult Function()? topUpSuccess,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
    required TResult Function(_WithdrawalSuccess value) withdrawalSuccess,
    required TResult Function(_WithdrawalSuccess value) withdrawalSuccess,
    required TResult Function(_BankLinkSuccess value) bankLinkSuccess,
    required TResult Function(_PaymentRequired value) paymentRequired,
    required TResult Function(_TopUpSuccess value) topUpSuccess,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
    TResult? Function(_WithdrawalSuccess value)? withdrawalSuccess,
    TResult? Function(_WithdrawalSuccess value)? withdrawalSuccess,
    TResult? Function(_BankLinkSuccess value)? bankLinkSuccess,
    TResult? Function(_PaymentRequired value)? paymentRequired,
    TResult? Function(_TopUpSuccess value)? topUpSuccess,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    TResult Function(_WithdrawalSuccess value)? withdrawalSuccess,
    TResult Function(_WithdrawalSuccess value)? withdrawalSuccess,
    TResult Function(_BankLinkSuccess value)? bankLinkSuccess,
    TResult Function(_PaymentRequired value)? paymentRequired,
    TResult Function(_TopUpSuccess value)? topUpSuccess,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial implements WalletState {
  const factory _Initial() = _$InitialImpl;
}

/// @nodoc
abstract class _$$LoadingImplCopyWith<$Res> {
  factory _$$LoadingImplCopyWith(
          _$LoadingImpl value, $Res Function(_$LoadingImpl) then) =
      __$$LoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadingImplCopyWithImpl<$Res>
    extends _$WalletStateCopyWithImpl<$Res, _$LoadingImpl>
    implements _$$LoadingImplCopyWith<$Res> {
  __$$LoadingImplCopyWithImpl(
      _$LoadingImpl _value, $Res Function(_$LoadingImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$LoadingImpl implements _Loading {
  const _$LoadingImpl();

  @override
  String toString() {
    return 'WalletState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(double balance, String currency,
            List<dynamic> transactions, bool isBankLinked)
        loaded,
    required TResult Function(String message) error,
    required TResult Function() withdrawalSuccess,
    required TResult Function() withdrawalSuccess,
    required TResult Function() bankLinkSuccess,
    required TResult Function(String orderId, double amount, String keyId)
        paymentRequired,
    required TResult Function() topUpSuccess,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(double balance, String currency,
            List<dynamic> transactions, bool isBankLinked)?
        loaded,
    TResult? Function(String message)? error,
    TResult? Function()? withdrawalSuccess,
    TResult? Function()? withdrawalSuccess,
    TResult? Function()? bankLinkSuccess,
    TResult? Function(String orderId, double amount, String keyId)?
        paymentRequired,
    TResult? Function()? topUpSuccess,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(double balance, String currency,
            List<dynamic> transactions, bool isBankLinked)?
        loaded,
    TResult Function(String message)? error,
    TResult Function()? withdrawalSuccess,
    TResult Function()? withdrawalSuccess,
    TResult Function()? bankLinkSuccess,
    TResult Function(String orderId, double amount, String keyId)?
        paymentRequired,
    TResult Function()? topUpSuccess,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
    required TResult Function(_WithdrawalSuccess value) withdrawalSuccess,
    required TResult Function(_WithdrawalSuccess value) withdrawalSuccess,
    required TResult Function(_BankLinkSuccess value) bankLinkSuccess,
    required TResult Function(_PaymentRequired value) paymentRequired,
    required TResult Function(_TopUpSuccess value) topUpSuccess,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
    TResult? Function(_WithdrawalSuccess value)? withdrawalSuccess,
    TResult? Function(_WithdrawalSuccess value)? withdrawalSuccess,
    TResult? Function(_BankLinkSuccess value)? bankLinkSuccess,
    TResult? Function(_PaymentRequired value)? paymentRequired,
    TResult? Function(_TopUpSuccess value)? topUpSuccess,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    TResult Function(_WithdrawalSuccess value)? withdrawalSuccess,
    TResult Function(_WithdrawalSuccess value)? withdrawalSuccess,
    TResult Function(_BankLinkSuccess value)? bankLinkSuccess,
    TResult Function(_PaymentRequired value)? paymentRequired,
    TResult Function(_TopUpSuccess value)? topUpSuccess,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _Loading implements WalletState {
  const factory _Loading() = _$LoadingImpl;
}

/// @nodoc
abstract class _$$LoadedImplCopyWith<$Res> {
  factory _$$LoadedImplCopyWith(
          _$LoadedImpl value, $Res Function(_$LoadedImpl) then) =
      __$$LoadedImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {double balance,
      String currency,
      List<dynamic> transactions,
      bool isBankLinked});
}

/// @nodoc
class __$$LoadedImplCopyWithImpl<$Res>
    extends _$WalletStateCopyWithImpl<$Res, _$LoadedImpl>
    implements _$$LoadedImplCopyWith<$Res> {
  __$$LoadedImplCopyWithImpl(
      _$LoadedImpl _value, $Res Function(_$LoadedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? balance = null,
    Object? currency = null,
    Object? transactions = null,
    Object? isBankLinked = null,
  }) {
    return _then(_$LoadedImpl(
      balance: null == balance
          ? _value.balance
          : balance // ignore: cast_nullable_to_non_nullable
              as double,
      currency: null == currency
          ? _value.currency
          : currency // ignore: cast_nullable_to_non_nullable
              as String,
      transactions: null == transactions
          ? _value._transactions
          : transactions // ignore: cast_nullable_to_non_nullable
              as List<dynamic>,
      isBankLinked: null == isBankLinked
          ? _value.isBankLinked
          : isBankLinked // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$LoadedImpl implements _Loaded {
  const _$LoadedImpl(
      {required this.balance,
      required this.currency,
      required final List<dynamic> transactions,
      required this.isBankLinked})
      : _transactions = transactions;

  @override
  final double balance;
  @override
  final String currency;
  final List<dynamic> _transactions;
  @override
  List<dynamic> get transactions {
    if (_transactions is EqualUnmodifiableListView) return _transactions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_transactions);
  }

  @override
  final bool isBankLinked;

  @override
  String toString() {
    return 'WalletState.loaded(balance: $balance, currency: $currency, transactions: $transactions, isBankLinked: $isBankLinked)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoadedImpl &&
            (identical(other.balance, balance) || other.balance == balance) &&
            (identical(other.currency, currency) ||
                other.currency == currency) &&
            const DeepCollectionEquality()
                .equals(other._transactions, _transactions) &&
            (identical(other.isBankLinked, isBankLinked) ||
                other.isBankLinked == isBankLinked));
  }

  @override
  int get hashCode => Object.hash(runtimeType, balance, currency,
      const DeepCollectionEquality().hash(_transactions), isBankLinked);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LoadedImplCopyWith<_$LoadedImpl> get copyWith =>
      __$$LoadedImplCopyWithImpl<_$LoadedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(double balance, String currency,
            List<dynamic> transactions, bool isBankLinked)
        loaded,
    required TResult Function(String message) error,
    required TResult Function() withdrawalSuccess,
    required TResult Function() withdrawalSuccess,
    required TResult Function() bankLinkSuccess,
    required TResult Function(String orderId, double amount, String keyId)
        paymentRequired,
    required TResult Function() topUpSuccess,
  }) {
    return loaded(balance, currency, transactions, isBankLinked);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(double balance, String currency,
            List<dynamic> transactions, bool isBankLinked)?
        loaded,
    TResult? Function(String message)? error,
    TResult? Function()? withdrawalSuccess,
    TResult? Function()? withdrawalSuccess,
    TResult? Function()? bankLinkSuccess,
    TResult? Function(String orderId, double amount, String keyId)?
        paymentRequired,
    TResult? Function()? topUpSuccess,
  }) {
    return loaded?.call(balance, currency, transactions, isBankLinked);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(double balance, String currency,
            List<dynamic> transactions, bool isBankLinked)?
        loaded,
    TResult Function(String message)? error,
    TResult Function()? withdrawalSuccess,
    TResult Function()? withdrawalSuccess,
    TResult Function()? bankLinkSuccess,
    TResult Function(String orderId, double amount, String keyId)?
        paymentRequired,
    TResult Function()? topUpSuccess,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(balance, currency, transactions, isBankLinked);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
    required TResult Function(_WithdrawalSuccess value) withdrawalSuccess,
    required TResult Function(_WithdrawalSuccess value) withdrawalSuccess,
    required TResult Function(_BankLinkSuccess value) bankLinkSuccess,
    required TResult Function(_PaymentRequired value) paymentRequired,
    required TResult Function(_TopUpSuccess value) topUpSuccess,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
    TResult? Function(_WithdrawalSuccess value)? withdrawalSuccess,
    TResult? Function(_WithdrawalSuccess value)? withdrawalSuccess,
    TResult? Function(_BankLinkSuccess value)? bankLinkSuccess,
    TResult? Function(_PaymentRequired value)? paymentRequired,
    TResult? Function(_TopUpSuccess value)? topUpSuccess,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    TResult Function(_WithdrawalSuccess value)? withdrawalSuccess,
    TResult Function(_WithdrawalSuccess value)? withdrawalSuccess,
    TResult Function(_BankLinkSuccess value)? bankLinkSuccess,
    TResult Function(_PaymentRequired value)? paymentRequired,
    TResult Function(_TopUpSuccess value)? topUpSuccess,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class _Loaded implements WalletState {
  const factory _Loaded(
      {required final double balance,
      required final String currency,
      required final List<dynamic> transactions,
      required final bool isBankLinked}) = _$LoadedImpl;

  double get balance;
  String get currency;
  List<dynamic> get transactions;
  bool get isBankLinked;
  @JsonKey(ignore: true)
  _$$LoadedImplCopyWith<_$LoadedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ErrorImplCopyWith<$Res> {
  factory _$$ErrorImplCopyWith(
          _$ErrorImpl value, $Res Function(_$ErrorImpl) then) =
      __$$ErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$ErrorImplCopyWithImpl<$Res>
    extends _$WalletStateCopyWithImpl<$Res, _$ErrorImpl>
    implements _$$ErrorImplCopyWith<$Res> {
  __$$ErrorImplCopyWithImpl(
      _$ErrorImpl _value, $Res Function(_$ErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$ErrorImpl(
      null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ErrorImpl implements _Error {
  const _$ErrorImpl(this.message);

  @override
  final String message;

  @override
  String toString() {
    return 'WalletState.error(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ErrorImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ErrorImplCopyWith<_$ErrorImpl> get copyWith =>
      __$$ErrorImplCopyWithImpl<_$ErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(double balance, String currency,
            List<dynamic> transactions, bool isBankLinked)
        loaded,
    required TResult Function(String message) error,
    required TResult Function() withdrawalSuccess,
    required TResult Function() withdrawalSuccess,
    required TResult Function() bankLinkSuccess,
    required TResult Function(String orderId, double amount, String keyId)
        paymentRequired,
    required TResult Function() topUpSuccess,
  }) {
    return error(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(double balance, String currency,
            List<dynamic> transactions, bool isBankLinked)?
        loaded,
    TResult? Function(String message)? error,
    TResult? Function()? withdrawalSuccess,
    TResult? Function()? withdrawalSuccess,
    TResult? Function()? bankLinkSuccess,
    TResult? Function(String orderId, double amount, String keyId)?
        paymentRequired,
    TResult? Function()? topUpSuccess,
  }) {
    return error?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(double balance, String currency,
            List<dynamic> transactions, bool isBankLinked)?
        loaded,
    TResult Function(String message)? error,
    TResult Function()? withdrawalSuccess,
    TResult Function()? withdrawalSuccess,
    TResult Function()? bankLinkSuccess,
    TResult Function(String orderId, double amount, String keyId)?
        paymentRequired,
    TResult Function()? topUpSuccess,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
    required TResult Function(_WithdrawalSuccess value) withdrawalSuccess,
    required TResult Function(_WithdrawalSuccess value) withdrawalSuccess,
    required TResult Function(_BankLinkSuccess value) bankLinkSuccess,
    required TResult Function(_PaymentRequired value) paymentRequired,
    required TResult Function(_TopUpSuccess value) topUpSuccess,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
    TResult? Function(_WithdrawalSuccess value)? withdrawalSuccess,
    TResult? Function(_WithdrawalSuccess value)? withdrawalSuccess,
    TResult? Function(_BankLinkSuccess value)? bankLinkSuccess,
    TResult? Function(_PaymentRequired value)? paymentRequired,
    TResult? Function(_TopUpSuccess value)? topUpSuccess,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    TResult Function(_WithdrawalSuccess value)? withdrawalSuccess,
    TResult Function(_WithdrawalSuccess value)? withdrawalSuccess,
    TResult Function(_BankLinkSuccess value)? bankLinkSuccess,
    TResult Function(_PaymentRequired value)? paymentRequired,
    TResult Function(_TopUpSuccess value)? topUpSuccess,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class _Error implements WalletState {
  const factory _Error(final String message) = _$ErrorImpl;

  String get message;
  @JsonKey(ignore: true)
  _$$ErrorImplCopyWith<_$ErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$WithdrawalSuccessImplCopyWith<$Res> {
  factory _$$WithdrawalSuccessImplCopyWith(_$WithdrawalSuccessImpl value,
          $Res Function(_$WithdrawalSuccessImpl) then) =
      __$$WithdrawalSuccessImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$WithdrawalSuccessImplCopyWithImpl<$Res>
    extends _$WalletStateCopyWithImpl<$Res, _$WithdrawalSuccessImpl>
    implements _$$WithdrawalSuccessImplCopyWith<$Res> {
  __$$WithdrawalSuccessImplCopyWithImpl(_$WithdrawalSuccessImpl _value,
      $Res Function(_$WithdrawalSuccessImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$WithdrawalSuccessImpl implements _WithdrawalSuccess {
  const _$WithdrawalSuccessImpl();

  @override
  String toString() {
    return 'WalletState.withdrawalSuccess()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$WithdrawalSuccessImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(double balance, String currency,
            List<dynamic> transactions, bool isBankLinked)
        loaded,
    required TResult Function(String message) error,
    required TResult Function() withdrawalSuccess,
    required TResult Function() withdrawalSuccess,
    required TResult Function() bankLinkSuccess,
    required TResult Function(String orderId, double amount, String keyId)
        paymentRequired,
    required TResult Function() topUpSuccess,
  }) {
    return withdrawalSuccess();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(double balance, String currency,
            List<dynamic> transactions, bool isBankLinked)?
        loaded,
    TResult? Function(String message)? error,
    TResult? Function()? withdrawalSuccess,
    TResult? Function()? withdrawalSuccess,
    TResult? Function()? bankLinkSuccess,
    TResult? Function(String orderId, double amount, String keyId)?
        paymentRequired,
    TResult? Function()? topUpSuccess,
  }) {
    return withdrawalSuccess?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(double balance, String currency,
            List<dynamic> transactions, bool isBankLinked)?
        loaded,
    TResult Function(String message)? error,
    TResult Function()? withdrawalSuccess,
    TResult Function()? withdrawalSuccess,
    TResult Function()? bankLinkSuccess,
    TResult Function(String orderId, double amount, String keyId)?
        paymentRequired,
    TResult Function()? topUpSuccess,
    required TResult orElse(),
  }) {
    if (withdrawalSuccess != null) {
      return withdrawalSuccess();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
    required TResult Function(_WithdrawalSuccess value) withdrawalSuccess,
    required TResult Function(_WithdrawalSuccess value) withdrawalSuccess,
    required TResult Function(_BankLinkSuccess value) bankLinkSuccess,
    required TResult Function(_PaymentRequired value) paymentRequired,
    required TResult Function(_TopUpSuccess value) topUpSuccess,
  }) {
    return withdrawalSuccess(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
    TResult? Function(_WithdrawalSuccess value)? withdrawalSuccess,
    TResult? Function(_WithdrawalSuccess value)? withdrawalSuccess,
    TResult? Function(_BankLinkSuccess value)? bankLinkSuccess,
    TResult? Function(_PaymentRequired value)? paymentRequired,
    TResult? Function(_TopUpSuccess value)? topUpSuccess,
  }) {
    return withdrawalSuccess?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    TResult Function(_WithdrawalSuccess value)? withdrawalSuccess,
    TResult Function(_WithdrawalSuccess value)? withdrawalSuccess,
    TResult Function(_BankLinkSuccess value)? bankLinkSuccess,
    TResult Function(_PaymentRequired value)? paymentRequired,
    TResult Function(_TopUpSuccess value)? topUpSuccess,
    required TResult orElse(),
  }) {
    if (withdrawalSuccess != null) {
      return withdrawalSuccess(this);
    }
    return orElse();
  }
}

abstract class _WithdrawalSuccess implements WalletState {
  const factory _WithdrawalSuccess() = _$WithdrawalSuccessImpl;
}

/// @nodoc
abstract class _$$WithdrawalSuccessImplCopyWith<$Res> {
  factory _$$WithdrawalSuccessImplCopyWith(_$WithdrawalSuccessImpl value,
          $Res Function(_$WithdrawalSuccessImpl) then) =
      __$$WithdrawalSuccessImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$WithdrawalSuccessImplCopyWithImpl<$Res>
    extends _$WalletStateCopyWithImpl<$Res, _$WithdrawalSuccessImpl>
    implements _$$WithdrawalSuccessImplCopyWith<$Res> {
  __$$WithdrawalSuccessImplCopyWithImpl(_$WithdrawalSuccessImpl _value,
      $Res Function(_$WithdrawalSuccessImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$WithdrawalSuccessImpl implements _WithdrawalSuccess {
  const _$WithdrawalSuccessImpl();

  @override
  String toString() {
    return 'WalletState.withdrawalSuccess()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$WithdrawalSuccessImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(double balance, String currency,
            List<dynamic> transactions, bool isBankLinked)
        loaded,
    required TResult Function(String message) error,
    required TResult Function() withdrawalSuccess,
    required TResult Function() withdrawalSuccess,
    required TResult Function() bankLinkSuccess,
    required TResult Function(String orderId, double amount, String keyId)
        paymentRequired,
    required TResult Function() topUpSuccess,
  }) {
    return withdrawalSuccess();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(double balance, String currency,
            List<dynamic> transactions, bool isBankLinked)?
        loaded,
    TResult? Function(String message)? error,
    TResult? Function()? withdrawalSuccess,
    TResult? Function()? withdrawalSuccess,
    TResult? Function()? bankLinkSuccess,
    TResult? Function(String orderId, double amount, String keyId)?
        paymentRequired,
    TResult? Function()? topUpSuccess,
  }) {
    return withdrawalSuccess?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(double balance, String currency,
            List<dynamic> transactions, bool isBankLinked)?
        loaded,
    TResult Function(String message)? error,
    TResult Function()? withdrawalSuccess,
    TResult Function()? withdrawalSuccess,
    TResult Function()? bankLinkSuccess,
    TResult Function(String orderId, double amount, String keyId)?
        paymentRequired,
    TResult Function()? topUpSuccess,
    required TResult orElse(),
  }) {
    if (withdrawalSuccess != null) {
      return withdrawalSuccess();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
    required TResult Function(_WithdrawalSuccess value) withdrawalSuccess,
    required TResult Function(_WithdrawalSuccess value) withdrawalSuccess,
    required TResult Function(_BankLinkSuccess value) bankLinkSuccess,
    required TResult Function(_PaymentRequired value) paymentRequired,
    required TResult Function(_TopUpSuccess value) topUpSuccess,
  }) {
    return withdrawalSuccess(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
    TResult? Function(_WithdrawalSuccess value)? withdrawalSuccess,
    TResult? Function(_WithdrawalSuccess value)? withdrawalSuccess,
    TResult? Function(_BankLinkSuccess value)? bankLinkSuccess,
    TResult? Function(_PaymentRequired value)? paymentRequired,
    TResult? Function(_TopUpSuccess value)? topUpSuccess,
  }) {
    return withdrawalSuccess?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    TResult Function(_WithdrawalSuccess value)? withdrawalSuccess,
    TResult Function(_WithdrawalSuccess value)? withdrawalSuccess,
    TResult Function(_BankLinkSuccess value)? bankLinkSuccess,
    TResult Function(_PaymentRequired value)? paymentRequired,
    TResult Function(_TopUpSuccess value)? topUpSuccess,
    required TResult orElse(),
  }) {
    if (withdrawalSuccess != null) {
      return withdrawalSuccess(this);
    }
    return orElse();
  }
}

abstract class _WithdrawalSuccess implements WalletState {
  const factory _WithdrawalSuccess() = _$WithdrawalSuccessImpl;
}

/// @nodoc
abstract class _$$BankLinkSuccessImplCopyWith<$Res> {
  factory _$$BankLinkSuccessImplCopyWith(_$BankLinkSuccessImpl value,
          $Res Function(_$BankLinkSuccessImpl) then) =
      __$$BankLinkSuccessImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$BankLinkSuccessImplCopyWithImpl<$Res>
    extends _$WalletStateCopyWithImpl<$Res, _$BankLinkSuccessImpl>
    implements _$$BankLinkSuccessImplCopyWith<$Res> {
  __$$BankLinkSuccessImplCopyWithImpl(
      _$BankLinkSuccessImpl _value, $Res Function(_$BankLinkSuccessImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$BankLinkSuccessImpl implements _BankLinkSuccess {
  const _$BankLinkSuccessImpl();

  @override
  String toString() {
    return 'WalletState.bankLinkSuccess()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$BankLinkSuccessImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(double balance, String currency,
            List<dynamic> transactions, bool isBankLinked)
        loaded,
    required TResult Function(String message) error,
    required TResult Function() withdrawalSuccess,
    required TResult Function() withdrawalSuccess,
    required TResult Function() bankLinkSuccess,
    required TResult Function(String orderId, double amount, String keyId)
        paymentRequired,
    required TResult Function() topUpSuccess,
  }) {
    return bankLinkSuccess();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(double balance, String currency,
            List<dynamic> transactions, bool isBankLinked)?
        loaded,
    TResult? Function(String message)? error,
    TResult? Function()? withdrawalSuccess,
    TResult? Function()? withdrawalSuccess,
    TResult? Function()? bankLinkSuccess,
    TResult? Function(String orderId, double amount, String keyId)?
        paymentRequired,
    TResult? Function()? topUpSuccess,
  }) {
    return bankLinkSuccess?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(double balance, String currency,
            List<dynamic> transactions, bool isBankLinked)?
        loaded,
    TResult Function(String message)? error,
    TResult Function()? withdrawalSuccess,
    TResult Function()? withdrawalSuccess,
    TResult Function()? bankLinkSuccess,
    TResult Function(String orderId, double amount, String keyId)?
        paymentRequired,
    TResult Function()? topUpSuccess,
    required TResult orElse(),
  }) {
    if (bankLinkSuccess != null) {
      return bankLinkSuccess();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
    required TResult Function(_WithdrawalSuccess value) withdrawalSuccess,
    required TResult Function(_WithdrawalSuccess value) withdrawalSuccess,
    required TResult Function(_BankLinkSuccess value) bankLinkSuccess,
    required TResult Function(_PaymentRequired value) paymentRequired,
    required TResult Function(_TopUpSuccess value) topUpSuccess,
  }) {
    return bankLinkSuccess(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
    TResult? Function(_WithdrawalSuccess value)? withdrawalSuccess,
    TResult? Function(_WithdrawalSuccess value)? withdrawalSuccess,
    TResult? Function(_BankLinkSuccess value)? bankLinkSuccess,
    TResult? Function(_PaymentRequired value)? paymentRequired,
    TResult? Function(_TopUpSuccess value)? topUpSuccess,
  }) {
    return bankLinkSuccess?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    TResult Function(_WithdrawalSuccess value)? withdrawalSuccess,
    TResult Function(_WithdrawalSuccess value)? withdrawalSuccess,
    TResult Function(_BankLinkSuccess value)? bankLinkSuccess,
    TResult Function(_PaymentRequired value)? paymentRequired,
    TResult Function(_TopUpSuccess value)? topUpSuccess,
    required TResult orElse(),
  }) {
    if (bankLinkSuccess != null) {
      return bankLinkSuccess(this);
    }
    return orElse();
  }
}

abstract class _BankLinkSuccess implements WalletState {
  const factory _BankLinkSuccess() = _$BankLinkSuccessImpl;
}

/// @nodoc
abstract class _$$PaymentRequiredImplCopyWith<$Res> {
  factory _$$PaymentRequiredImplCopyWith(_$PaymentRequiredImpl value,
          $Res Function(_$PaymentRequiredImpl) then) =
      __$$PaymentRequiredImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String orderId, double amount, String keyId});
}

/// @nodoc
class __$$PaymentRequiredImplCopyWithImpl<$Res>
    extends _$WalletStateCopyWithImpl<$Res, _$PaymentRequiredImpl>
    implements _$$PaymentRequiredImplCopyWith<$Res> {
  __$$PaymentRequiredImplCopyWithImpl(
      _$PaymentRequiredImpl _value, $Res Function(_$PaymentRequiredImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? orderId = null,
    Object? amount = null,
    Object? keyId = null,
  }) {
    return _then(_$PaymentRequiredImpl(
      orderId: null == orderId
          ? _value.orderId
          : orderId // ignore: cast_nullable_to_non_nullable
              as String,
      amount: null == amount
          ? _value.amount
          : amount // ignore: cast_nullable_to_non_nullable
              as double,
      keyId: null == keyId
          ? _value.keyId
          : keyId // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$PaymentRequiredImpl implements _PaymentRequired {
  const _$PaymentRequiredImpl(
      {required this.orderId, required this.amount, required this.keyId});

  @override
  final String orderId;
  @override
  final double amount;
  @override
  final String keyId;

  @override
  String toString() {
    return 'WalletState.paymentRequired(orderId: $orderId, amount: $amount, keyId: $keyId)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PaymentRequiredImpl &&
            (identical(other.orderId, orderId) || other.orderId == orderId) &&
            (identical(other.amount, amount) || other.amount == amount) &&
            (identical(other.keyId, keyId) || other.keyId == keyId));
  }

  @override
  int get hashCode => Object.hash(runtimeType, orderId, amount, keyId);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PaymentRequiredImplCopyWith<_$PaymentRequiredImpl> get copyWith =>
      __$$PaymentRequiredImplCopyWithImpl<_$PaymentRequiredImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(double balance, String currency,
            List<dynamic> transactions, bool isBankLinked)
        loaded,
    required TResult Function(String message) error,
    required TResult Function() withdrawalSuccess,
    required TResult Function() withdrawalSuccess,
    required TResult Function() bankLinkSuccess,
    required TResult Function(String orderId, double amount, String keyId)
        paymentRequired,
    required TResult Function() topUpSuccess,
  }) {
    return paymentRequired(orderId, amount, keyId);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(double balance, String currency,
            List<dynamic> transactions, bool isBankLinked)?
        loaded,
    TResult? Function(String message)? error,
    TResult? Function()? withdrawalSuccess,
    TResult? Function()? withdrawalSuccess,
    TResult? Function()? bankLinkSuccess,
    TResult? Function(String orderId, double amount, String keyId)?
        paymentRequired,
    TResult? Function()? topUpSuccess,
  }) {
    return paymentRequired?.call(orderId, amount, keyId);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(double balance, String currency,
            List<dynamic> transactions, bool isBankLinked)?
        loaded,
    TResult Function(String message)? error,
    TResult Function()? withdrawalSuccess,
    TResult Function()? withdrawalSuccess,
    TResult Function()? bankLinkSuccess,
    TResult Function(String orderId, double amount, String keyId)?
        paymentRequired,
    TResult Function()? topUpSuccess,
    required TResult orElse(),
  }) {
    if (paymentRequired != null) {
      return paymentRequired(orderId, amount, keyId);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
    required TResult Function(_WithdrawalSuccess value) withdrawalSuccess,
    required TResult Function(_WithdrawalSuccess value) withdrawalSuccess,
    required TResult Function(_BankLinkSuccess value) bankLinkSuccess,
    required TResult Function(_PaymentRequired value) paymentRequired,
    required TResult Function(_TopUpSuccess value) topUpSuccess,
  }) {
    return paymentRequired(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
    TResult? Function(_WithdrawalSuccess value)? withdrawalSuccess,
    TResult? Function(_WithdrawalSuccess value)? withdrawalSuccess,
    TResult? Function(_BankLinkSuccess value)? bankLinkSuccess,
    TResult? Function(_PaymentRequired value)? paymentRequired,
    TResult? Function(_TopUpSuccess value)? topUpSuccess,
  }) {
    return paymentRequired?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    TResult Function(_WithdrawalSuccess value)? withdrawalSuccess,
    TResult Function(_WithdrawalSuccess value)? withdrawalSuccess,
    TResult Function(_BankLinkSuccess value)? bankLinkSuccess,
    TResult Function(_PaymentRequired value)? paymentRequired,
    TResult Function(_TopUpSuccess value)? topUpSuccess,
    required TResult orElse(),
  }) {
    if (paymentRequired != null) {
      return paymentRequired(this);
    }
    return orElse();
  }
}

abstract class _PaymentRequired implements WalletState {
  const factory _PaymentRequired(
      {required final String orderId,
      required final double amount,
      required final String keyId}) = _$PaymentRequiredImpl;

  String get orderId;
  double get amount;
  String get keyId;
  @JsonKey(ignore: true)
  _$$PaymentRequiredImplCopyWith<_$PaymentRequiredImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$TopUpSuccessImplCopyWith<$Res> {
  factory _$$TopUpSuccessImplCopyWith(
          _$TopUpSuccessImpl value, $Res Function(_$TopUpSuccessImpl) then) =
      __$$TopUpSuccessImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$TopUpSuccessImplCopyWithImpl<$Res>
    extends _$WalletStateCopyWithImpl<$Res, _$TopUpSuccessImpl>
    implements _$$TopUpSuccessImplCopyWith<$Res> {
  __$$TopUpSuccessImplCopyWithImpl(
      _$TopUpSuccessImpl _value, $Res Function(_$TopUpSuccessImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$TopUpSuccessImpl implements _TopUpSuccess {
  const _$TopUpSuccessImpl();

  @override
  String toString() {
    return 'WalletState.topUpSuccess()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$TopUpSuccessImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(double balance, String currency,
            List<dynamic> transactions, bool isBankLinked)
        loaded,
    required TResult Function(String message) error,
    required TResult Function() withdrawalSuccess,
    required TResult Function() withdrawalSuccess,
    required TResult Function() bankLinkSuccess,
    required TResult Function(String orderId, double amount, String keyId)
        paymentRequired,
    required TResult Function() topUpSuccess,
  }) {
    return topUpSuccess();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(double balance, String currency,
            List<dynamic> transactions, bool isBankLinked)?
        loaded,
    TResult? Function(String message)? error,
    TResult? Function()? withdrawalSuccess,
    TResult? Function()? withdrawalSuccess,
    TResult? Function()? bankLinkSuccess,
    TResult? Function(String orderId, double amount, String keyId)?
        paymentRequired,
    TResult? Function()? topUpSuccess,
  }) {
    return topUpSuccess?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(double balance, String currency,
            List<dynamic> transactions, bool isBankLinked)?
        loaded,
    TResult Function(String message)? error,
    TResult Function()? withdrawalSuccess,
    TResult Function()? withdrawalSuccess,
    TResult Function()? bankLinkSuccess,
    TResult Function(String orderId, double amount, String keyId)?
        paymentRequired,
    TResult Function()? topUpSuccess,
    required TResult orElse(),
  }) {
    if (topUpSuccess != null) {
      return topUpSuccess();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
    required TResult Function(_WithdrawalSuccess value) withdrawalSuccess,
    required TResult Function(_WithdrawalSuccess value) withdrawalSuccess,
    required TResult Function(_BankLinkSuccess value) bankLinkSuccess,
    required TResult Function(_PaymentRequired value) paymentRequired,
    required TResult Function(_TopUpSuccess value) topUpSuccess,
  }) {
    return topUpSuccess(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
    TResult? Function(_WithdrawalSuccess value)? withdrawalSuccess,
    TResult? Function(_WithdrawalSuccess value)? withdrawalSuccess,
    TResult? Function(_BankLinkSuccess value)? bankLinkSuccess,
    TResult? Function(_PaymentRequired value)? paymentRequired,
    TResult? Function(_TopUpSuccess value)? topUpSuccess,
  }) {
    return topUpSuccess?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    TResult Function(_WithdrawalSuccess value)? withdrawalSuccess,
    TResult Function(_WithdrawalSuccess value)? withdrawalSuccess,
    TResult Function(_BankLinkSuccess value)? bankLinkSuccess,
    TResult Function(_PaymentRequired value)? paymentRequired,
    TResult Function(_TopUpSuccess value)? topUpSuccess,
    required TResult orElse(),
  }) {
    if (topUpSuccess != null) {
      return topUpSuccess(this);
    }
    return orElse();
  }
}

abstract class _TopUpSuccess implements WalletState {
  const factory _TopUpSuccess() = _$TopUpSuccessImpl;
}
